## 分帧与帧移


在能量VAD（Voice Activity Detection）中，`frame_width_` 和 `frame_shift_` 是两个重要的参数，它们控制了滑动窗口的大小和移动步长，影响着如何对音频信号进行分析和处理。

1. **`frame_width_`（帧宽度）**：
   - 它决定了每个分析窗口的持续时间。较长的帧宽度意味着每个分析窗口包含更多的音频信号。
   - 较长的帧宽度可以提供更多的上下文信息，有助于捕捉到音频信号中的长期特征，比如语音的音调、基本频率等。
   - 然而，过长的帧宽度可能导致信号变化较快的部分被模糊化，无法捕捉到短期的语音特征，比如语音的爆发性声音或瞬态信号。
   - 因此，选择合适的帧宽度需要权衡长期和短期特征的捕捉需求。

2. **`frame_shift_`（帧移）**：
   - 它决定了分析窗口在音频信号上的滑动步长，即每次移动的距离。
   - 较小的帧移会导致窗口之间重叠较多，提供更多重叠区域，有助于提高信号连续性，但也会增加计算量。
   - 较大的帧移可能导致窗口之间的信息丢失，因为连续窗口之间的重叠区域减少，难以捕捉到信号的快速变化或短时特征。
   - 合理选择帧移可以平衡时域分析的灵敏度和计算效率。

在实际应用中，这两个参数的选择需要考虑到信号的性质、分析需求以及计算效率。一般来说，常见的实践是通过实验和经验选择合适的帧宽度和帧移来达到最佳的声音活动检测效果。

## 能量检测的使用

1. 概念wavform
2. 特征向量的处理
特征向量在这里是指的是采样点
针对 feats 中的每个特征向量，代码通过迭代计算了一个能量分数。

内层循环:
对于每个特征向量 feat 中的每个样本 s，代码执行了一系列操作。在这个循环中，fabs(s) 计算了每个样本的绝对值，然后将其除以 32768.f。这个操作可能是将音频数据归一化到 [-1, 1] 的范围内。

计算能量分数:
接着，将所有样本的归一化值相加并除以特征向量的长度，计算得到一个标准化的平均值作为能量分数 score。

当创建一个用于计算声波能量的类时

## 更多的声音特征


```c++

int EnergyScore::forward(float* pcm_data, int pcm_len, bool is_end,
		std::vector<float>& scores, std::vector<int>& size) {
	std::vector<std::vector<float>> feats;
	int ret = accept_waveform(pcm_data, pcm_len, is_end, feats);
	for (auto& feat : feats) {
		float normalized_sum = 0.0f;
		for (auto s : feat) {
			normalized_sum += fabs(s) / 32768.f;
		}

		float score = normalized_sum / feat.size();
		//LOG(INFO) << "Energy score: " << score;
		scores.push_back(1.0 - score);
		scores.push_back(score);
	}
	size.push_back(feats.size());
	size.push_back(2);

	return 0;
}
```
在这段代码中，将两个分数（`1.0 - score` 和 `score`）推送到 `scores` 向量的目的可能是为了提供更多关于每个特征向量能量水平的信息。通常，这样做可能有几个目的：

1. **提供更丰富的信息**：
   将两个分数推送到 `scores` 向量中，使得每个特征向量都有两个对应的分数。这样做可以在后续处理中提供更多关于能量分布的信息。例如，一个分数可以用来表示声音活跃度，另一个分数可以表示非活跃度。这种方法可以更全面地描述特征向量的声音活跃程度和静音程度。

2. **方便后续处理**：
   在某些情况下，可能需要同时考虑两种状态（声音活跃和静音）的可能性。推送两个分数使得可以更容易地在后续的算法或决策过程中使用这些值。

3. **阈值选择**：
   如果后续处理需要基于阈值来判断声音活跃度，推送两个分数可能有助于更准确地设置阈值。这样做可以提供对活跃和非活跃部分的更全面认识，帮助确定合适的阈值来区分这两种状态。

需要注意的是，这种方法可能会增加数据的存储和处理成本。在实际应用中，根据具体情况，选择是否需要同时存储两个分数可能会有所不同。ba